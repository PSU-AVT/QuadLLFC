/******************************************************************* 
 * Header file generated by Protoc for Embedded C.                 *
 * Version 0.1 (2011-AUG-01)                                       *
 *                                                                 *
 * Copyright (c) 2009-2011                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : control.proto
 * Package: 
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/


#define MAX_REPEATED_LEN 32
#define MAX_STRING_LEN 32

/*******************************************************************
 * General functions
 *******************************************************************/

/*
 * returns the size of a length delimited message which also 
 * contains the first bytes for the length encoding.
 */
unsigned long Message_get_delimited_size(void *_buffer, int offset);

/*
 * Tests whether a message can be completely read from the given buffer at
 * the offset. The bytes [offset..offset+length-1] are interpreted.
 *
 * Returns 1 (true) if buffer[offset..offset+length-1] contains a complete
 * message or 0 (false) otherwise.
 */
int Message_can_read_delimited_from(void *_buffer, int offset, int length);


/*******************************************************************
 * Enumeration: control.proto, line 1
 *******************************************************************/
enum ControlAxisType {
  _Roll = 1,
  _Pitch = 2,
  _Yaw = 3,
  _X = 4,
  _Y = 5,
  _Z = 6
};

/*******************************************************************
 * Enumeration: control.proto, line 10
 *******************************************************************/
enum ControlMsgType {
  _Error = 1,
  _AxisSet = 2,
  _AxisGet = 3
};

/*******************************************************************
 * Enumeration: control.proto, line 16
 *******************************************************************/
enum ControlErrorType {
  _UnsupportedMsg = 1,
  _InvalidMsg = 2
};

/*******************************************************************
 * Message: control.proto, line 21
 *******************************************************************/

/* Maximum size of a serialized ControlError-message, useful for buffer allocation. */
#define MAX_ControlError_SIZE 8

/* Structure that holds a deserialized ControlError-message. */
struct ControlError {
  enum ControlErrorType _type;
  enum ControlMsgType _error_msg_type;
};
/*
 * Serialize a ControlError-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int ControlError_write_delimited_to(struct ControlError *_ControlError, void *_buffer, int offset);

/*
 * Deserialize a ControlError-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _ControlError will be reset to 0 before _buffer is interpreted.
 */
int ControlError_read_delimited_from(void *_buffer, struct ControlError *_ControlError, int offset);


/*******************************************************************
 * Message: control.proto, line 26
 *******************************************************************/

/* Maximum size of a serialized ControlAxisSet-message, useful for buffer allocation. */
#define MAX_ControlAxisSet_SIZE 11

/* Structure that holds a deserialized ControlAxisSet-message. */
struct ControlAxisSet {
  enum ControlAxisType _axis;
  float _value;
};
/*
 * Serialize a ControlAxisSet-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int ControlAxisSet_write_delimited_to(struct ControlAxisSet *_ControlAxisSet, void *_buffer, int offset);

/*
 * Deserialize a ControlAxisSet-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _ControlAxisSet will be reset to 0 before _buffer is interpreted.
 */
int ControlAxisSet_read_delimited_from(void *_buffer, struct ControlAxisSet *_ControlAxisSet, int offset);


/*******************************************************************
 * Message: control.proto, line 32
 *******************************************************************/

/* Maximum size of a serialized ControlAxisGet-message, useful for buffer allocation. */
#define MAX_ControlAxisGet_SIZE 11

/* Structure that holds a deserialized ControlAxisGet-message. */
struct ControlAxisGet {
  enum ControlAxisType _axis;
  float _value;
};
/*
 * Serialize a ControlAxisGet-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int ControlAxisGet_write_delimited_to(struct ControlAxisGet *_ControlAxisGet, void *_buffer, int offset);

/*
 * Deserialize a ControlAxisGet-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _ControlAxisGet will be reset to 0 before _buffer is interpreted.
 */
int ControlAxisGet_read_delimited_from(void *_buffer, struct ControlAxisGet *_ControlAxisGet, int offset);


/*******************************************************************
 * Message: control.proto, line 37
 *******************************************************************/

/* Maximum size of a serialized ControlMsgHeader-message, useful for buffer allocation. */
#define MAX_ControlMsgHeader_SIZE 29

/* Structure that holds a deserialized ControlMsgHeader-message. */
struct ControlMsgHeader {
  enum ControlMsgType _type;
  signed long _length;
  signed long _crc;
};
/*
 * Serialize a ControlMsgHeader-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int ControlMsgHeader_write_delimited_to(struct ControlMsgHeader *_ControlMsgHeader, void *_buffer, int offset);

/*
 * Deserialize a ControlMsgHeader-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _ControlMsgHeader will be reset to 0 before _buffer is interpreted.
 */
int ControlMsgHeader_read_delimited_from(void *_buffer, struct ControlMsgHeader *_ControlMsgHeader, int offset);
