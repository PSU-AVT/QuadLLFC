/******************************************************************* 
 * C-file generated by Protoc for Embedded C.                      *
 * Version 0.1 (2011-AUG-01)                                       *
 *                                                                 *
 * Copyright (c) 2009-2011                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : control.proto
 * Package: 
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/

#include "control.h"

/*******************************************************************
 * General functions
 *******************************************************************/
 
void _memset(void *msg_ptr, char init_val, unsigned int size) {
    int i;
    for(i = 0; i < size; ++ i)
        *((char*)msg_ptr + i) = init_val;
}

int varint_packed_size(unsigned long value) {
    if ((value & (0xffffffff <<  7)) == 0) return 1;
    if ((value & (0xffffffff << 14)) == 0) return 2;
    if ((value & (0xffffffff << 21)) == 0) return 3;
    if ((value & (0xffffffff << 28)) == 0) return 4;
    return 5;  
}

int write_raw_byte(char value, void *_buffer, int offset) {
    *((char *)_buffer + offset) = value;
    return ++offset;
}

/** Write a little-endian 32-bit integer. */
int write_raw_little_endian32(unsigned long value, void *_buffer, int offset) {
    offset = write_raw_byte((char)((value      ) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >>  8) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 16) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 24) & 0xFF), _buffer, offset);
    
    return offset;
}

int write_raw_varint32(unsigned long value, void *_buffer, int offset) {
    unsigned long sign = 1 & (value >> 31);
    while (1) {
        if ((value & ~0x7F) == 0) {
             if (sign) {
              // Must sign extend to 64 bit.
              offset = write_raw_byte(0xF0 | value, _buffer, offset);
              offset = write_raw_byte(255, _buffer, offset);
              offset = write_raw_byte(255, _buffer, offset);
              offset = write_raw_byte(255, _buffer, offset);
              offset = write_raw_byte(255, _buffer, offset);
              offset = write_raw_byte(1, _buffer, offset);
            } else {
              offset = write_raw_byte((char)value, _buffer, offset);
            }
            return offset;
        } else {
            offset = write_raw_byte((char)((value & 0x7F) | 0x80), _buffer, offset);
            value = value >> 7;
        }
    }
    return offset;
}

int write_raw_bytes(char *bytes, int bytes_size, void *_buffer, int offset) {
    int i; 
    for(i = 0; i < bytes_size; ++ i) {
        offset = write_raw_byte((char)*(bytes + i), _buffer, offset);
    }
    
    return offset;   
}

int read_raw_byte(char *tag, void *_buffer, int offset) {
    *tag = *((char *) _buffer + offset);
    
    return ++offset;
}

/** Read a 32-bit little-endian integer from the stream. */
int read_raw_little_endian32(unsigned long *tag, void *_buffer, int offset) {
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b1 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b2 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b3 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b4 = (char) *tag;
    
    *tag = (((unsigned long)b1 & 0xff)      ) |
           (((unsigned long)b2 & 0xff) <<  8) |
           (((unsigned long)b3 & 0xff) << 16) |
           (((unsigned long)b4 & 0xff) << 24);
           
    return offset;
}

int read_raw_varint32(unsigned long *tag, void *_buffer, int offset) {
    char result;
    
    offset = read_raw_byte(&result, _buffer, offset);
    if (result >= 0) {
        *tag = result;
        return offset;
    }
    *tag = result & 0x7f;
    offset = read_raw_byte(&result, _buffer, offset);
    if (result >= 0) {
        *tag |= result << 7;
    } else {
        *tag |= (result & 0x7f) << 7;
        offset = read_raw_byte(&result, _buffer, offset);
        if (result >= 0) {
            *tag |= result << 14;
        } else {
            *tag |= (result & 0x7f) << 14;
            offset = read_raw_byte(&result, _buffer, offset);
            if (result >= 0) {
                *tag |= result << 21;
            } else {
                *tag |= (result & 0x7f) << 21;
                offset = read_raw_byte(&result, _buffer, offset);
                *tag |= result << 28;
                if (result < 0) {
                    // Discard upper 32 bits.
                    int i;
                    for (i = 0; i < 5; ++ i) {
                        offset = read_raw_byte(&result, _buffer, offset);
                        if (result >= 0) {
                            return offset;
                        }
                    }
                    //invalid state
                }
            }
        }
    }
    return offset;
}

int can_read_raw_varint32(void *_buffer, int offset, int length) {
    char c;
    
    // Bound length to valid range [0..5].
    if (length < 0) length = 0; else
    if (length > 5) length = 5;
    
    while (length > 0) {
        offset = read_raw_byte(&c, _buffer, offset);
        if (c >= 0) {
            return 1; // Can read (1 == true).
        }
        length--;
    }
    
    return 0; // Cannot read (0 == false).
}

int Message_can_read_delimited_from(void *_buffer, int offset, int length) {
    unsigned long size;
    int payload_offset;

    if (length <= 0) return 0; // Cannot read from empty or invalid message.

    if (!can_read_raw_varint32(_buffer, offset, length)) {
        return 0; // Could not even read the preceding size as varint32.
    }

    payload_offset = read_raw_varint32(&size, _buffer, offset);
    length = length - (payload_offset - offset);

    return (length >= size) ? 1 : 0;
}

unsigned long Message_get_delimited_size(void *_buffer, int offset) {
    unsigned long size = 0;
    int old_offset = offset;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    
    return size + offset - old_offset;
}


/*******************************************************************
 * Enum: control.proto, line 1
 *******************************************************************/
int AxisType_write_with_tag(enum AxisType *_AxisType, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_AxisType, _buffer, offset);
    
    return offset;
}

/*******************************************************************
 * Enum: control.proto, line 10
 *******************************************************************/
int ControlMsgType_write_with_tag(enum ControlMsgType *_ControlMsgType, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_ControlMsgType, _buffer, offset);
    
    return offset;
}

/*******************************************************************
 * Message: control.proto, line 15
 *******************************************************************/
int AxisSet_write(struct AxisSet *_AxisSet, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = AxisType_write_with_tag(&_AxisSet->_axis, _buffer, offset, 1);
    offset = write_raw_varint32((2<<3)+5, _buffer, offset);
    unsigned long *value_ptr = (unsigned long *)&_AxisSet->_value;
    offset = write_raw_little_endian32(*value_ptr, _buffer, offset);

    
    return offset;
}

int AxisSet_write_with_tag(struct AxisSet *_AxisSet, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = AxisSet_write(_AxisSet, _buffer, offset);
    
    return offset;
}

int AxisSet_write_delimited_to(struct AxisSet *_AxisSet, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = AxisSet_write(_AxisSet, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

void AxisSet_clear(struct AxisSet *_AxisSet) {
    _memset(_AxisSet, 0, sizeof(struct AxisSet));
}

int AxisSet_read(void *_buffer, struct AxisSet *_AxisSet, int offset, int limit) {
    int i = 0;
    unsigned long tag = i;

/* Reset all attributes to 0 in advance. */
    AxisSet_clear(_AxisSet);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            //tag of: _AxisSet._axis 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _AxisSet->_axis = tag;
                break;
            //tag of: _AxisSet._value 
            case 2 :
                offset = read_raw_little_endian32(&tag, _buffer, offset);
                float *value = (float *)(&tag);
                _AxisSet->_value = *value;
                break;
        }
    }
    
    return offset;
}

int AxisSet_read_delimited_from(void *_buffer, struct AxisSet *_AxisSet, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    AxisSet_read(_buffer, _AxisSet, offset, size + offset);
    
    return offset + size;
}


/*******************************************************************
 * Message: control.proto, line 21
 *******************************************************************/
int AxisGet_write(struct AxisGet *_AxisGet, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = AxisType_write_with_tag(&_AxisGet->_axis, _buffer, offset, 1);
    offset = write_raw_varint32((2<<3)+5, _buffer, offset);
    unsigned long *value_ptr = (unsigned long *)&_AxisGet->_value;
    offset = write_raw_little_endian32(*value_ptr, _buffer, offset);

    
    return offset;
}

int AxisGet_write_with_tag(struct AxisGet *_AxisGet, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = AxisGet_write(_AxisGet, _buffer, offset);
    
    return offset;
}

int AxisGet_write_delimited_to(struct AxisGet *_AxisGet, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = AxisGet_write(_AxisGet, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

void AxisGet_clear(struct AxisGet *_AxisGet) {
    _memset(_AxisGet, 0, sizeof(struct AxisGet));
}

int AxisGet_read(void *_buffer, struct AxisGet *_AxisGet, int offset, int limit) {
    int i = 0;
    unsigned long tag = i;

/* Reset all attributes to 0 in advance. */
    AxisGet_clear(_AxisGet);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            //tag of: _AxisGet._axis 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _AxisGet->_axis = tag;
                break;
            //tag of: _AxisGet._value 
            case 2 :
                offset = read_raw_little_endian32(&tag, _buffer, offset);
                float *value = (float *)(&tag);
                _AxisGet->_value = *value;
                break;
        }
    }
    
    return offset;
}

int AxisGet_read_delimited_from(void *_buffer, struct AxisGet *_AxisGet, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    AxisGet_read(_buffer, _AxisGet, offset, size + offset);
    
    return offset + size;
}


/*******************************************************************
 * Message: control.proto, line 26
 *******************************************************************/
int ControlMsgHeader_write(struct ControlMsgHeader *_ControlMsgHeader, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = ControlMsgType_write_with_tag(&_ControlMsgHeader->_type, _buffer, offset, 1);
    offset = write_raw_varint32((2<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_ControlMsgHeader->_length, _buffer, offset);

    offset = write_raw_varint32((3<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_ControlMsgHeader->_crc, _buffer, offset);

    
    return offset;
}

int ControlMsgHeader_write_with_tag(struct ControlMsgHeader *_ControlMsgHeader, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = ControlMsgHeader_write(_ControlMsgHeader, _buffer, offset);
    
    return offset;
}

int ControlMsgHeader_write_delimited_to(struct ControlMsgHeader *_ControlMsgHeader, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = ControlMsgHeader_write(_ControlMsgHeader, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

void ControlMsgHeader_clear(struct ControlMsgHeader *_ControlMsgHeader) {
    _memset(_ControlMsgHeader, 0, sizeof(struct ControlMsgHeader));
}

int ControlMsgHeader_read(void *_buffer, struct ControlMsgHeader *_ControlMsgHeader, int offset, int limit) {
    int i = 0;
    unsigned long tag = i;

/* Reset all attributes to 0 in advance. */
    ControlMsgHeader_clear(_ControlMsgHeader);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            //tag of: _ControlMsgHeader._type 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _ControlMsgHeader->_type = tag;
                break;
            //tag of: _ControlMsgHeader._length 
            case 2 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _ControlMsgHeader->_length = (signed long)tag;
                break;
            //tag of: _ControlMsgHeader._crc 
            case 3 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _ControlMsgHeader->_crc = (signed long)tag;
                break;
        }
    }
    
    return offset;
}

int ControlMsgHeader_read_delimited_from(void *_buffer, struct ControlMsgHeader *_ControlMsgHeader, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    ControlMsgHeader_read(_buffer, _ControlMsgHeader, offset, size + offset);
    
    return offset + size;
}
